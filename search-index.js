var searchIndex = {};
searchIndex['solicit'] = {"items":[[0,"","solicit","",null,null],[0,"http","","The module implements the framing layer of HTTP/2 and exposes an API for using it.",null,null],[3,"HeaderPart","solicit::http","A convenience struct representing a part of a header (either the name or the value) that can be\neither an owned or a borrowed byte sequence.",null,null],[3,"Header","","Represents an HTTP/2 header. Allows both the name and the value to be either an owned or a\nborrowed byte sequence.",null,null],[3,"ConnectionError","","The struct represents a connection error arising on an HTTP/2 connection.",null,null],[3,"WindowSize","","The struct represents the size of a flow control window.",null,null],[3,"Response","","A struct representing the full raw response received on an HTTP/2 connection.",null,null],[12,"stream_id","","The ID of the stream to which the response is associated. HTTP/1.1 does\nnot really have an equivalent to this.",0,null],[12,"headers","","Exposes *all* the raw response headers, including the meta-headers.\n(For now the only meta header allowed in HTTP/2 responses is the\n`:status`.)",0,null],[12,"body","","The full body of the response as an uninterpreted sequence of bytes.",0,null],[3,"Request","","A struct representing a full HTTP/2 request, along with the full body, as a\nsequence of bytes.",null,null],[12,"stream_id","","",1,null],[12,"headers","","",1,null],[12,"body","","",1,null],[4,"ErrorCode","","The enum represents an error code that are used in `RST_STREAM` and `GOAWAY` frames.\nThese are defined in [Section 7](http://http2.github.io/http2-spec/#ErrorCodes) of the HTTP/2\nspec.",null,null],[13,"NoError","","The associated condition is not a result of an error. For example, a GOAWAY might include\nthis code to indicate graceful shutdown of a connection.",2,null],[13,"ProtocolError","","The endpoint detected an unspecific protocol error. This error is for use when a more\nspecific error code is not available.",2,null],[13,"InternalError","","The endpoint encountered an unexpected internal error.",2,null],[13,"FlowControlError","","The endpoint detected that its peer violated the flow-control protocol.",2,null],[13,"SettingsTimeout","","The endpoint sent a SETTINGS frame but did not receive a response in a timely manner. See\nSection 6.5.3 (\"Settings Synchronization\").",2,null],[13,"StreamClosed","","The endpoint received a frame after a stream was half-closed.",2,null],[13,"FrameSizeError","","The endpoint received a frame with an invalid size.",2,null],[13,"RefusedStream","","The endpoint refused the stream prior to performing any application processing (see Section\n8.1.4 for details).",2,null],[13,"Cancel","","Used by the endpoint to indicate that the stream is no longer needed.",2,null],[13,"CompressionError","","The endpoint is unable to maintain the header compression context for the connection.",2,null],[13,"ConnectError","","The connection established in response to a CONNECT request (Section 8.3) was reset or\nabnormally closed.",2,null],[13,"EnhanceYourCalm","","The endpoint detected that its peer is exhibiting a behavior that might be generating\nexcessive load.",2,null],[13,"InadequateSecurity","","The underlying transport has properties that do not meet minimum security requirements (see\nSection 9.2).",2,null],[13,"Http11Required","","The endpoint requires that HTTP/1.1 be used instead of HTTP/2.",2,null],[4,"HttpError","","An enum representing errors that can arise when performing operations involving an HTTP/2\nconnection.",null,null],[13,"IoError","","The underlying IO layer raised an error",3,null],[13,"InvalidFrame","","The HTTP/2 connection received an invalid HTTP/2 frame",3,null],[13,"PeerConnectionError","","The peer indicated a connection error",3,null],[13,"CompressionError","","The HPACK decoder was unable to decode a header chunk and raised an error.\nAny decoder error is fatal to the HTTP/2 connection as it means that the decoder contexts\nwill be out of sync.",3,null],[13,"WindowSizeOverflow","","Indicates that the local peer has discovered an overflow in the size of one of the\nconnection flow control window, which is a connection error.",3,null],[13,"UnknownStreamId","","",3,null],[13,"UnableToConnect","","",3,null],[13,"MalformedResponse","","",3,null],[13,"Other","","",3,null],[4,"HttpScheme","","An enum representing the two possible HTTP schemes.",null,null],[13,"Http","","The variant corresponding to `http://`",4,null],[13,"Https","","The variant corresponding to `https://`",4,null],[0,"frame","","The module contains the implementation of HTTP/2 frames.",null,null],[3,"NoFlag","solicit::http::frame","A helper struct that can be used by all frames that do not define any flags.",null,null],[3,"RawFrame","","A struct that defines the format of the raw HTTP/2 frame, i.e. the frame\nas it is read from the wire.",null,null],[5,"unpack_header","","Deconstructs a `FrameHeader` into its corresponding 4 components,\nrepresented as a 4-tuple: `(length, frame_type, flags, stream_id)`.",null,{"inputs":[{"name":"frameheaderbuffer"}],"output":{"name":"frameheader"}}],[5,"pack_header","","Constructs a buffer of 9 bytes that represents the given `FrameHeader`.",null,{"inputs":[{"name":"frameheader"}],"output":{"name":"frameheaderbuffer"}}],[0,"builder","","Defines the `FrameBuilder` trait and some default implementations of the trait.",null,null],[8,"FrameBuilder","solicit::http::frame::builder","A trait that provides additional methods for serializing HTTP/2 frames.",null,null],[11,"write_header","","Write the given frame header as the next octets (i.e. without moving the cursor to the\nbeginning of the buffer).",5,{"inputs":[{"name":"framebuilder"},{"name":"frameheader"}],"output":{"name":"result"}}],[11,"overwrite_header","","Overwrite the previously written header, assuming it's the first byte sequence of the\nbuffer.",5,{"inputs":[{"name":"framebuilder"},{"name":"frameheader"}],"output":{"name":"result"}}],[11,"copy_bytes_from","","Copy all available bytes from the given `io::Read` instance.",5,{"inputs":[{"name":"framebuilder"},{"name":"r"}],"output":{"name":"result"}}],[11,"write_padding","","Write the given number of padding octets.",5,{"inputs":[{"name":"framebuilder"},{"name":"u8"}],"output":{"name":"result"}}],[11,"write_u32","","Write the given unsigned 32 bit integer to the underlying stream. The integer is written as\nfour bytes in network endian style.",5,{"inputs":[{"name":"framebuilder"},{"name":"u32"}],"output":{"name":"result"}}],[0,"data","solicit::http::frame","The module contains the implementation of the `DATA` frame and associated flags.",null,null],[3,"DataChunk","solicit::http::frame::data","A helper struct that allows the chunk to be either borrowed or owned. Used to provide the\n`From` implementations that allow us to implement generic methods that accept any type that can\nbe converted into a `DataChunk` (given that the native `Cow` type does not have these\nimplementations and we cannot add them).",null,null],[3,"DataFrame","","A struct representing the DATA frames of HTTP/2, as defined in the HTTP/2\nspec, section 6.1.",null,null],[12,"data","","The data found in the frame as an opaque byte sequence. It never\nincludes padding bytes.",6,null],[4,"DataFlag","","An enum representing the flags that a `DataFrame` can have.\nThe integer representation associated to each variant is that flag's\nbitmask.",null,null],[13,"EndStream","","",7,null],[13,"Padded","","",7,null],[11,"clone","","",7,{"inputs":[{"name":"dataflag"}],"output":{"name":"dataflag"}}],[11,"eq","","",7,{"inputs":[{"name":"dataflag"},{"name":"dataflag"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"dataflag"},{"name":"dataflag"}],"output":{"name":"bool"}}],[11,"fmt","","",7,{"inputs":[{"name":"dataflag"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bitmask","","",7,{"inputs":[{"name":"dataflag"}],"output":{"name":"u8"}}],[11,"from","","",8,{"inputs":[{"name":"datachunk"},{"name":"vec"}],"output":{"name":"datachunk"}}],[11,"from","","",8,null],[11,"eq","","",6,{"inputs":[{"name":"dataframe"},{"name":"dataframe"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"dataframe"},{"name":"dataframe"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"dataframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"dataframe"}],"output":{"name":"dataframe"}}],[11,"new","","Creates a new empty `DataFrame`, associated to the stream with the\ngiven ID.",6,{"inputs":[{"name":"dataframe"},{"name":"streamid"}],"output":{"name":"dataframe"}}],[11,"with_data","","Creates a new `DataFrame` with the given `DataChunk`.",6,{"inputs":[{"name":"dataframe"},{"name":"streamid"},{"name":"d"}],"output":{"name":"dataframe"}}],[11,"is_padded","","Returns `true` if the DATA frame is padded, otherwise false.",6,{"inputs":[{"name":"dataframe"}],"output":{"name":"bool"}}],[11,"is_end_of_stream","","Returns whther this frame ends the stream it is associated with.",6,{"inputs":[{"name":"dataframe"}],"output":{"name":"bool"}}],[11,"set_padding","","Sets the number of bytes that should be used as padding for this\nframe.",6,{"inputs":[{"name":"dataframe"},{"name":"u8"}],"output":null}],[11,"payload_len","","Returns the total length of the payload, taking into account possible\npadding.",6,{"inputs":[{"name":"dataframe"}],"output":{"name":"u32"}}],[11,"set_flag","","Sets the given flag for the frame.",6,{"inputs":[{"name":"dataframe"},{"name":"dataflag"}],"output":null}],[11,"from_raw","","Creates a new `DataFrame` from the given `RawFrame` (i.e. header and\npayload), if possible.  Returns `None` if a valid `DataFrame` cannot be\nconstructed from the given `RawFrame`.",6,{"inputs":[{"name":"dataframe"},{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","Tests if the given flag is set for the frame.",6,{"inputs":[{"name":"dataframe"},{"name":"dataflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated.",6,{"inputs":[{"name":"dataframe"}],"output":{"name":"streamid"}}],[11,"get_header","","Returns a `FrameHeader` based on the current state of the frame.",6,{"inputs":[{"name":"dataframe"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",6,{"inputs":[{"name":"dataframe"},{"name":"b"}],"output":{"name":"result"}}],[0,"headers","solicit::http::frame","The module contains the implementation of the `HEADERS` frame and associated flags.",null,null],[3,"StreamDependency","solicit::http::frame::headers","The struct represents the dependency information that can be attached to\na stream and sent within a HEADERS frame (one with the Priority flag set).",null,null],[12,"stream_id","","The ID of the stream that a particular stream depends on",9,null],[12,"weight","","The weight for the stream. The value exposed (and set) here is always\nin the range [0, 255], instead of [1, 256] \\(as defined in section 5.3.2.)\nso that the value fits into a `u8`.",9,null],[12,"is_exclusive","","A flag indicating whether the stream dependency is exclusive.",9,null],[3,"HeadersFrame","","A struct representing the HEADERS frames of HTTP/2, as defined in the\nHTTP/2 spec, section 6.2.",null,null],[12,"stream_id","","The ID of the stream with which this frame is associated",10,null],[12,"stream_dep","","The stream dependency information, if any.",10,null],[12,"padding_len","","The length of the padding, if any.",10,null],[4,"HeadersFlag","","An enum representing the flags that a `HeadersFrame` can have.\nThe integer representation associated to each variant is that flag's\nbitmask.",null,null],[13,"EndStream","","",11,null],[13,"EndHeaders","","",11,null],[13,"Padded","","",11,null],[13,"Priority","","",11,null],[11,"clone","","",11,{"inputs":[{"name":"headersflag"}],"output":{"name":"headersflag"}}],[11,"eq","","",11,{"inputs":[{"name":"headersflag"},{"name":"headersflag"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"headersflag"},{"name":"headersflag"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"headersflag"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bitmask","","",11,{"inputs":[{"name":"headersflag"}],"output":{"name":"u8"}}],[11,"eq","","",9,{"inputs":[{"name":"streamdependency"},{"name":"streamdependency"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"streamdependency"},{"name":"streamdependency"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"streamdependency"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"streamdependency"}],"output":{"name":"streamdependency"}}],[11,"new","","Creates a new `StreamDependency` with the given stream ID, weight, and\nexclusivity.",9,{"inputs":[{"name":"streamdependency"},{"name":"streamid"},{"name":"u8"},{"name":"bool"}],"output":{"name":"streamdependency"}}],[11,"parse","","Parses the first 5 bytes in the buffer as a `StreamDependency`.\n(Each 5-byte sequence is always decodable into a stream dependency\nstructure).",9,null],[11,"serialize","","Serializes the `StreamDependency` into a 5-byte buffer representing the\ndependency description, as described in section 6.2. of the HTTP/2\nspec:",9,null],[11,"eq","","",10,{"inputs":[{"name":"headersframe"},{"name":"headersframe"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"headersframe"},{"name":"headersframe"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"headersframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"headersframe"}],"output":{"name":"headersframe"}}],[11,"new","","Creates a new `HeadersFrame` with the given header fragment and stream\nID. No padding, no stream dependency, and no flags are set.",10,{"inputs":[{"name":"headersframe"},{"name":"vec"},{"name":"streamid"}],"output":{"name":"headersframe"}}],[11,"with_dependency","","Creates a new `HeadersFrame` with the given header fragment, stream ID\nand stream dependency information. No padding and no flags are set.",10,{"inputs":[{"name":"headersframe"},{"name":"vec"},{"name":"streamid"},{"name":"streamdependency"}],"output":{"name":"headersframe"}}],[11,"is_headers_end","","Returns whether this frame ends the headers. If not, there MUST be a\nnumber of follow up CONTINUATION frames that send the rest of the\nheader data.",10,{"inputs":[{"name":"headersframe"}],"output":{"name":"bool"}}],[11,"is_end_of_stream","","Returns whther this frame ends the stream it is associated with.",10,{"inputs":[{"name":"headersframe"}],"output":{"name":"bool"}}],[11,"set_padding","","Sets the padding length for the frame, as well as the corresponding\nPadded flag.",10,{"inputs":[{"name":"headersframe"},{"name":"u8"}],"output":null}],[11,"header_fragment","","",10,null],[11,"set_flag","","Sets the given flag for the frame.",10,{"inputs":[{"name":"headersframe"},{"name":"headersflag"}],"output":null}],[11,"from_raw","","Creates a new `HeadersFrame` with the given `RawFrame` (i.e. header and\npayload), if possible.",10,{"inputs":[{"name":"headersframe"},{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","Tests if the given flag is set for the frame.",10,{"inputs":[{"name":"headersframe"},{"name":"headersflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated.",10,{"inputs":[{"name":"headersframe"}],"output":{"name":"streamid"}}],[11,"get_header","","Returns a `FrameHeader` based on the current state of the `Frame`.",10,{"inputs":[{"name":"headersframe"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",10,{"inputs":[{"name":"headersframe"},{"name":"b"}],"output":{"name":"result"}}],[0,"rst_stream","solicit::http::frame","The module contains the implementation of the `RST_STREAM` frame.",null,null],[3,"RstStreamFrame","solicit::http::frame::rst_stream","The struct represents the `RST_STREAM` HTTP/2 frame.",null,null],[17,"RST_STREAM_FRAME_LEN","","The total allowed size for the `RST_STREAM` frame payload.",null,null],[17,"RST_STREAM_FRAME_TYPE","","The frame type of the `RST_STREAM` frame.",null,null],[11,"eq","","",12,{"inputs":[{"name":"rststreamframe"},{"name":"rststreamframe"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"rststreamframe"},{"name":"rststreamframe"}],"output":{"name":"bool"}}],[11,"fmt","","",12,{"inputs":[{"name":"rststreamframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"rststreamframe"}],"output":{"name":"rststreamframe"}}],[11,"new","","Constructs a new `RstStreamFrame` with the given `ErrorCode`.",12,{"inputs":[{"name":"rststreamframe"},{"name":"streamid"},{"name":"errorcode"}],"output":{"name":"rststreamframe"}}],[11,"with_raw_error_code","","Constructs a new `RstStreamFrame` that will use the given `raw_error_code` for its payload.",12,{"inputs":[{"name":"rststreamframe"},{"name":"streamid"},{"name":"u32"}],"output":{"name":"rststreamframe"}}],[11,"error_code","","Returns the interpreted error code of the frame. Any unknown error codes are mapped into\nthe `InternalError` variant of the enum.",12,{"inputs":[{"name":"rststreamframe"}],"output":{"name":"errorcode"}}],[11,"raw_error_code","","Returns the original raw error code of the frame. If the code is unknown, it will not be\nchanged.",12,{"inputs":[{"name":"rststreamframe"}],"output":{"name":"u32"}}],[11,"from_raw","","",12,{"inputs":[{"name":"rststreamframe"},{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","",12,{"inputs":[{"name":"rststreamframe"},{"name":"noflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","",12,{"inputs":[{"name":"rststreamframe"}],"output":{"name":"streamid"}}],[11,"get_header","","",12,{"inputs":[{"name":"rststreamframe"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",12,{"inputs":[{"name":"rststreamframe"},{"name":"b"}],"output":{"name":"result"}}],[0,"settings","solicit::http::frame","The module contains the implementation of the `SETTINGS` frame and associated flags.",null,null],[3,"SettingsFrame","solicit::http::frame::settings","A struct representing the SETTINGS frames of HTTP/2, as defined in the\nHTTP/2 spec, section 6.5.",null,null],[12,"settings","","Contains all the settings that are currently set in the frame. It is\nsafe to access this field (to read, add, or remove settings), even\nthough a helper method `add_setting` exists.",13,null],[4,"HttpSetting","","An enum that lists all valid settings that can be sent in a SETTINGS\nframe.",null,null],[13,"HeaderTableSize","","",14,null],[13,"EnablePush","","",14,null],[13,"MaxConcurrentStreams","","",14,null],[13,"InitialWindowSize","","",14,null],[13,"MaxFrameSize","","",14,null],[13,"MaxHeaderListSize","","",14,null],[4,"SettingsFlag","","An enum representing the flags that a `SettingsFrame` can have.\nThe integer representation associated to each variant is that flag's\nbitmask.",null,null],[13,"Ack","","",15,null],[11,"clone","","",14,{"inputs":[{"name":"httpsetting"}],"output":{"name":"httpsetting"}}],[11,"eq","","",14,{"inputs":[{"name":"httpsetting"},{"name":"httpsetting"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"httpsetting"},{"name":"httpsetting"}],"output":{"name":"bool"}}],[11,"fmt","","",14,{"inputs":[{"name":"httpsetting"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_id","","Creates a new `HttpSetting` with the correct variant corresponding to\nthe given setting id, based on the settings IDs defined in section\n6.5.2.",14,{"inputs":[{"name":"httpsetting"},{"name":"u16"},{"name":"u32"}],"output":{"name":"option"}}],[11,"get_id","","Returns the setting ID as an unsigned 16 bit integer, as defined in\nsection 6.5.2.",14,{"inputs":[{"name":"httpsetting"}],"output":{"name":"u16"}}],[11,"get_val","","Gets the setting value by unpacking it from the wrapped `u32`.",14,{"inputs":[{"name":"httpsetting"}],"output":{"name":"u32"}}],[11,"clone","","",15,{"inputs":[{"name":"settingsflag"}],"output":{"name":"settingsflag"}}],[11,"eq","","",15,{"inputs":[{"name":"settingsflag"},{"name":"settingsflag"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"settingsflag"},{"name":"settingsflag"}],"output":{"name":"bool"}}],[11,"fmt","","",15,{"inputs":[{"name":"settingsflag"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bitmask","","",15,{"inputs":[{"name":"settingsflag"}],"output":{"name":"u8"}}],[11,"eq","","",13,{"inputs":[{"name":"settingsframe"},{"name":"settingsframe"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"settingsframe"},{"name":"settingsframe"}],"output":{"name":"bool"}}],[11,"fmt","","",13,{"inputs":[{"name":"settingsframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"settingsframe"}],"output":{"name":"settingsframe"}}],[11,"new","","Creates a new `SettingsFrame`",13,{"inputs":[{"name":"settingsframe"}],"output":{"name":"settingsframe"}}],[11,"new_ack","","A convenience constructor that returns a `SettingsFrame` with the ACK\nflag already set and no settings.",13,{"inputs":[{"name":"settingsframe"}],"output":{"name":"settingsframe"}}],[11,"add_setting","","Adds the given setting to the frame.",13,{"inputs":[{"name":"settingsframe"},{"name":"httpsetting"}],"output":null}],[11,"set_ack","","Sets the ACK flag for the frame. This method is just a convenience\nmethod for calling `frame.set_flag(SettingsFlag::Ack)`.",13,{"inputs":[{"name":"settingsframe"}],"output":null}],[11,"is_ack","","Checks whether the `SettingsFrame` has an ACK attached to it.",13,{"inputs":[{"name":"settingsframe"}],"output":{"name":"bool"}}],[11,"set_flag","","Sets the given flag for the frame.",13,{"inputs":[{"name":"settingsframe"},{"name":"settingsflag"}],"output":null}],[11,"from_raw","","Creates a new `SettingsFrame` with the given `RawFrame` (i.e. header and\npayload), if possible.",13,{"inputs":[{"name":"settingsframe"},{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","Tests if the given flag is set for the frame.",13,{"inputs":[{"name":"settingsframe"},{"name":"settingsflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated.",13,{"inputs":[{"name":"settingsframe"}],"output":{"name":"streamid"}}],[11,"get_header","","Returns a `FrameHeader` based on the current state of the `Frame`.",13,{"inputs":[{"name":"settingsframe"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",13,{"inputs":[{"name":"settingsframe"},{"name":"b"}],"output":{"name":"result"}}],[0,"goaway","solicit::http::frame","Implements the `GOAWAY` HTTP/2 frame.",null,null],[3,"GoawayFrame","solicit::http::frame::goaway","The struct represents the `GOAWAY` HTTP/2 frame.",null,null],[17,"GOAWAY_MIN_FRAME_LEN","","The minimum size for the `GOAWAY` frame payload.\nIt is 8 octets, as the last stream id and error code are required parts of the GOAWAY frame.",null,null],[17,"GOAWAY_FRAME_TYPE","","The frame type of the `GOAWAY` frame.",null,null],[11,"eq","","",16,{"inputs":[{"name":"goawayframe"},{"name":"goawayframe"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"goawayframe"},{"name":"goawayframe"}],"output":{"name":"bool"}}],[11,"fmt","","",16,{"inputs":[{"name":"goawayframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"goawayframe"}],"output":{"name":"goawayframe"}}],[11,"new","","Create a new `GOAWAY` frame with the given error code and no debug data.",16,{"inputs":[{"name":"goawayframe"},{"name":"streamid"},{"name":"errorcode"}],"output":{"name":"self"}}],[11,"with_debug_data","","Create a new `GOAWAY` frame with the given parts.",16,null],[11,"error_code","","Returns the interpreted error code of the frame. Any unknown error codes are mapped into\nthe `InternalError` variant of the enum.",16,{"inputs":[{"name":"goawayframe"}],"output":{"name":"errorcode"}}],[11,"raw_error_code","","Returns the original raw error code of the frame. If the code is unknown, it will not be\nchanged.",16,{"inputs":[{"name":"goawayframe"}],"output":{"name":"u32"}}],[11,"last_stream_id","","Returns the associated last stream ID.",16,{"inputs":[{"name":"goawayframe"}],"output":{"name":"streamid"}}],[11,"debug_data","","Returns the debug data associated with the frame.",16,{"inputs":[{"name":"goawayframe"}],"output":{"name":"option"}}],[11,"payload_len","","Returns the total length of the frame's payload, including any debug data.",16,{"inputs":[{"name":"goawayframe"}],"output":{"name":"u32"}}],[11,"from_raw","","",16,{"inputs":[{"name":"goawayframe"},{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","",16,{"inputs":[{"name":"goawayframe"},{"name":"noflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","",16,{"inputs":[{"name":"goawayframe"}],"output":{"name":"streamid"}}],[11,"get_header","","",16,{"inputs":[{"name":"goawayframe"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",16,{"inputs":[{"name":"goawayframe"},{"name":"b"}],"output":{"name":"result"}}],[0,"window_update","solicit::http::frame","Implements the `WINDOW_UPDATE` HTTP/2 frame.",null,null],[3,"WindowUpdateFrame","solicit::http::frame::window_update","The struct represents the `WINDOW_UPDATE` HTTP/2 frame.",null,null],[17,"WINDOW_UPDATE_FRAME_LEN","","The minimum size for the `WINDOW_UPDATE` frame payload.",null,null],[17,"WINDOW_UPDATE_FRAME_TYPE","","The frame type of the `WINDOW_UPDATE` frame.",null,null],[11,"eq","","",17,{"inputs":[{"name":"windowupdateframe"},{"name":"windowupdateframe"}],"output":{"name":"bool"}}],[11,"ne","","",17,{"inputs":[{"name":"windowupdateframe"},{"name":"windowupdateframe"}],"output":{"name":"bool"}}],[11,"fmt","","",17,{"inputs":[{"name":"windowupdateframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"windowupdateframe"}],"output":{"name":"windowupdateframe"}}],[11,"for_connection","","Creates a new `WindowUpdateFrame` that will increment the connection-level window by the\ngiven increment.",17,{"inputs":[{"name":"windowupdateframe"},{"name":"u32"}],"output":{"name":"windowupdateframe"}}],[11,"for_stream","","Creates a new `WindowUpdateFrame` that will increment the given stream's window by the\ngiven increment.",17,{"inputs":[{"name":"windowupdateframe"},{"name":"streamid"},{"name":"u32"}],"output":{"name":"windowupdateframe"}}],[11,"increment","","Returns the window increment indicated by the frame.",17,{"inputs":[{"name":"windowupdateframe"}],"output":{"name":"u32"}}],[11,"from_raw","","",17,{"inputs":[{"name":"windowupdateframe"},{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","",17,{"inputs":[{"name":"windowupdateframe"},{"name":"noflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","",17,{"inputs":[{"name":"windowupdateframe"}],"output":{"name":"streamid"}}],[11,"get_header","","",17,{"inputs":[{"name":"windowupdateframe"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",17,{"inputs":[{"name":"windowupdateframe"},{"name":"b"}],"output":{"name":"result"}}],[6,"FrameHeaderBuffer","solicit::http::frame","An alias for the 9-byte buffer that each HTTP/2 frame header must be stored\nin.",null,null],[6,"FrameHeader","","An alias for the 4-tuple representing the components of each HTTP/2 frame\nheader.",null,null],[17,"FRAME_HEADER_LEN","","",null,null],[8,"FrameIR","","A trait that types that are an intermediate representation of HTTP/2 frames should implement.\nIt allows us to generically serialize any intermediate representation into an on-the-wire\nrepresentation.",null,null],[10,"serialize_into","","Write out the on-the-wire representation of the frame into the given `FrameBuilder`.",18,{"inputs":[{"name":"frameir"},{"name":"b"}],"output":{"name":"result"}}],[8,"Flag","","A trait that all HTTP/2 frame header flags need to implement.",null,null],[10,"bitmask","","Returns a bit mask that represents the flag.",19,{"inputs":[{"name":"flag"}],"output":{"name":"u8"}}],[8,"Frame","","A trait that all HTTP/2 frame structs need to implement.",null,null],[16,"FlagType","","The type that represents the flags that the particular `Frame` can take.\nThis makes sure that only valid `Flag`s are used with each `Frame`.",20,null],[10,"from_raw","","Creates a new `Frame` from the given `RawFrame` (i.e. header and\npayload), if possible.",20,{"inputs":[{"name":"frame"},{"name":"rawframe"}],"output":{"name":"option"}}],[10,"is_set","","Tests if the given flag is set for the frame.",20,{"inputs":[{"name":"frame"},{"name":"flagtype"}],"output":{"name":"bool"}}],[10,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated",20,{"inputs":[{"name":"frame"}],"output":{"name":"streamid"}}],[10,"get_header","","Returns a `FrameHeader` based on the current state of the `Frame`.",20,{"inputs":[{"name":"frame"}],"output":{"name":"frameheader"}}],[11,"bitmask","","",21,{"inputs":[{"name":"noflag"}],"output":{"name":"u8"}}],[11,"eq","","",22,{"inputs":[{"name":"rawframe"},{"name":"rawframe"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"rawframe"},{"name":"rawframe"}],"output":{"name":"bool"}}],[11,"fmt","","",22,{"inputs":[{"name":"rawframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"rawframe"}],"output":{"name":"rawframe"}}],[11,"parse","","Parses a `RawFrame` from the bytes starting at the beginning of the given buffer.",22,null],[11,"len","","Returns the total length of the `RawFrame`, including both headers, as well as the entire\npayload.",22,{"inputs":[{"name":"rawframe"}],"output":{"name":"usize"}}],[11,"serialize","","Returns a `Vec` of bytes representing the serialized (on-the-wire)\nrepresentation of this raw frame.",22,{"inputs":[{"name":"rawframe"}],"output":{"name":"vec"}}],[11,"header","","Returns a `FrameHeader` instance corresponding to the headers of the\n`RawFrame`.",22,{"inputs":[{"name":"rawframe"}],"output":{"name":"frameheader"}}],[11,"payload","","Returns a slice representing the payload of the `RawFrame`.",22,null],[11,"into","","",22,{"inputs":[{"name":"rawframe"}],"output":{"name":"vec"}}],[11,"as_ref","","",22,null],[11,"from","","",22,{"inputs":[{"name":"rawframe"},{"name":"vec"}],"output":{"name":"rawframe"}}],[11,"from","","",22,null],[11,"serialize_into","","",22,{"inputs":[{"name":"rawframe"},{"name":"b"}],"output":{"name":"result"}}],[0,"transport","solicit::http","The module contains implementations of the transport layer functionality\nthat HTTP/2 requires. It exposes APIs that allow the HTTP/2 connection to\nuse the transport layer without requiring it to know which exact\nimplementation they are using (e.g. a clear-text TCP connection, a TLS\nprotected connection, or even a mock implementation).",null,null],[3,"TransportReceiveFrame","solicit::http::transport","The struct is a an implementation of the `ReceiveFrame` trait that wraps an existing\n`TransportStream` and uses it to provide HTTP/2 frames, when asked for one, by reading from the\nstream.\nThe implementation always allocates a new buffer on the heap for every incoming frame.",null,null],[8,"TransportStream","","A trait that any struct that wants to provide the transport layer for\nHTTP/2 needs to implement.",null,null],[11,"read_exact","","A convenience method that performs as many `read` calls on the\nunderlying `Read` implementation as it takes to fill the given buffer.",23,null],[10,"try_split","","Attempts to split the `TransportStream` instance into a new independently\nowned handle to the same underlying stream.",23,{"inputs":[{"name":"transportstream"}],"output":{"name":"result"}}],[10,"close","","Attempts to shutdown both ends of the transport stream.",23,{"inputs":[{"name":"transportstream"}],"output":{"name":"result"}}],[11,"try_split","std::net::tcp","",24,{"inputs":[{"name":"tcpstream"}],"output":{"name":"result"}}],[11,"close","","",24,{"inputs":[{"name":"tcpstream"}],"output":{"name":"result"}}],[11,"new","solicit::http::transport","Create a new `TransportReceiveFrame` that will use the given `TransportStream` for reading\nthe frame.",25,{"inputs":[{"name":"transportreceiveframe"},{"name":"ts"}],"output":{"name":"transportreceiveframe"}}],[11,"recv_frame","","",25,{"inputs":[{"name":"transportreceiveframe"}],"output":{"name":"httpresult"}}],[11,"try_split","openssl::ssl","",26,{"inputs":[{"name":"sslstream"}],"output":{"name":"result"}}],[11,"close","","",26,{"inputs":[{"name":"sslstream"}],"output":{"name":"result"}}],[0,"connection","solicit::http","The module contains the implementation of an HTTP/2 connection.",null,null],[3,"HttpConnection","solicit::http::connection","The struct implements the HTTP/2 connection level logic.",null,null],[12,"scheme","","The scheme of the connection",27,null],[3,"DataChunk","","The struct represents a chunk of data that should be sent to the peer on a particular stream.",null,null],[12,"data","","The data that should be sent.",28,null],[12,"stream_id","","The ID of the stream on which the data should be sent.",28,null],[12,"end_stream","","Whether the data chunk will also end the stream.",28,null],[3,"HttpConnectionSender","","The struct represents an `HttpConnection` that has been bound to a `SendFrame` reference,\nallowing it to send frames. It exposes convenience methods for various send operations that can\nbe invoked on the underlying stream. The methods prepare the appropriate frames and queue their\nsending on the referenced `SendFrame` instance.",null,null],[4,"HttpFrame","","An enum representing all frame variants that can be returned by an `HttpConnection` can handle.",null,null],[13,"DataFrame","","",29,null],[13,"HeadersFrame","","",29,null],[13,"RstStreamFrame","","",29,null],[13,"SettingsFrame","","",29,null],[13,"GoawayFrame","","",29,null],[13,"WindowUpdateFrame","","",29,null],[13,"UnknownFrame","","",29,null],[4,"SendStatus","","The enum represents the success status of the operation of sending a next data chunk on an\nHTTP/2 connection.",null,null],[13,"Sent","","Indicates that a DATA frame was successfully sent",30,null],[13,"Nothing","","Indicates that nothing was sent, but that no errors occurred.",30,null],[4,"EndStream","","An enum indicating whether the `HttpConnection` send operation should end the stream.",null,null],[13,"Yes","","The stream should be closed",31,null],[13,"No","","The stream should still be kept open",31,null],[8,"SendFrame","","A trait that should be implemented by types that can provide the functionality\nof sending HTTP/2 frames.",null,null],[10,"send_frame","","Queue the given frame for immediate sending to the peer. It is the responsibility of each\nindividual `SendFrame` implementation to correctly serialize the given `FrameIR` into an\nappropriate buffer and make sure that the frame is subsequently eventually pushed to the\npeer.",32,{"inputs":[{"name":"sendframe"},{"name":"f"}],"output":{"name":"httpresult"}}],[8,"ReceiveFrame","","A trait that should be implemented by types that can provide the functionality\nof receiving HTTP/2 frames.",null,null],[10,"recv_frame","","Return a new `HttpFrame` instance. Unknown frames can be wrapped in the\n`HttpFrame::UnknownFrame` variant (i.e. their `RawFrame` representation).",33,{"inputs":[{"name":"receiveframe"}],"output":{"name":"httpresult"}}],[11,"eq","","",29,{"inputs":[{"name":"httpframe"},{"name":"httpframe"}],"output":{"name":"bool"}}],[11,"ne","","",29,{"inputs":[{"name":"httpframe"},{"name":"httpframe"}],"output":{"name":"bool"}}],[11,"fmt","","",29,{"inputs":[{"name":"httpframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",29,{"inputs":[{"name":"httpframe"}],"output":{"name":"httpframe"}}],[11,"from_raw","","",29,{"inputs":[{"name":"httpframe"},{"name":"rawframe"}],"output":{"name":"httpresult"}}],[11,"fmt","","",30,{"inputs":[{"name":"sendstatus"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",30,{"inputs":[{"name":"sendstatus"},{"name":"sendstatus"}],"output":{"name":"bool"}}],[11,"ne","","",30,{"inputs":[{"name":"sendstatus"},{"name":"sendstatus"}],"output":{"name":"bool"}}],[11,"clone","","",30,{"inputs":[{"name":"sendstatus"}],"output":{"name":"sendstatus"}}],[11,"new","","Creates a new `DataChunk`.",28,{"inputs":[{"name":"datachunk"},{"name":"cow"},{"name":"streamid"},{"name":"endstream"}],"output":{"name":"datachunk"}}],[11,"new_borrowed","","Creates a new `DataChunk` from a borrowed slice. This method should become obsolete if we\ncan take an `Into<Cow<_, _>>` without using unstable features.",28,{"inputs":[{"name":"datachunk"},{"name":"d"},{"name":"streamid"},{"name":"endstream"}],"output":{"name":"datachunk"}}],[11,"fmt","","",31,{"inputs":[{"name":"endstream"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",31,{"inputs":[{"name":"endstream"},{"name":"endstream"}],"output":{"name":"bool"}}],[11,"ne","","",31,{"inputs":[{"name":"endstream"},{"name":"endstream"}],"output":{"name":"bool"}}],[11,"clone","","",31,{"inputs":[{"name":"endstream"}],"output":{"name":"endstream"}}],[11,"send_settings_ack","","Sends a SETTINGS acknowledge frame to the peer.",34,{"inputs":[{"name":"httpconnectionsender"}],"output":{"name":"httpresult"}}],[11,"send_headers","","A helper function that inserts the frames required to send the given headers onto the\n`SendFrame` stream.",34,{"inputs":[{"name":"httpconnectionsender"},{"name":"h"},{"name":"streamid"},{"name":"endstream"}],"output":{"name":"httpresult"}}],[11,"send_data","","A helper function that inserts a frame representing the given data into the `SendFrame`\nstream. In doing so, the connection's outbound flow control window is adjusted\nappropriately.",34,{"inputs":[{"name":"httpconnectionsender"},{"name":"datachunk"}],"output":{"name":"httpresult"}}],[11,"send_next_data","","Sends the chunk of data provided by the given `DataPrioritizer`.",34,{"inputs":[{"name":"httpconnectionsender"},{"name":"p"}],"output":{"name":"httpresult"}}],[11,"new","","Creates a new `HttpConnection` that will use the given sender\nfor writing frames.",27,{"inputs":[{"name":"httpconnection"},{"name":"httpscheme"}],"output":{"name":"httpconnection"}}],[11,"sender","","Creates a new `HttpConnectionSender` instance that will use the given `SendFrame` instance\nto send the frames that it prepares. This is a convenience struct so that clients do not\nhave to pass the same `sender` reference to multiple send methods.",27,{"inputs":[{"name":"httpconnection"},{"name":"s"}],"output":{"name":"httpconnectionsender"}}],[11,"in_window_size","","Returns the current size of the inbound flow control window (i.e. the number of octets that\nthe connection will accept and the peer will send at most, unless the window is updated).",27,{"inputs":[{"name":"httpconnection"}],"output":{"name":"i32"}}],[11,"out_window_size","","Returns the current size of the outbound flow control window (i.e. the number of octets\nthat can be sent on the connection to the peer without violating flow control).",27,{"inputs":[{"name":"httpconnection"}],"output":{"name":"i32"}}],[11,"expect_settings","","The method processes the next frame provided by the given `ReceiveFrame` instance, expecting\nit to be a SETTINGS frame.\nAdditionally, the frame cannot be an ACK settings frame, but rather it should contain the\npeer's settings.",27,{"inputs":[{"name":"httpconnection"},{"name":"recv"},{"name":"sess"}],"output":{"name":"httpresult"}}],[11,"handle_next_frame","","Handles the next frame incoming on the given `ReceiveFrame` instance.",27,{"inputs":[{"name":"httpconnection"},{"name":"recv"},{"name":"sess"}],"output":{"name":"httpresult"}}],[0,"session","solicit::http","Defines the interface for the session-level management of HTTP/2\ncommunication. This is effectively an API that allows hooking into an\nHTTP/2 connection in order to handle events arising on the connection.",null,null],[3,"StreamIter","solicit::http::session","A newtype for an iterator over `Stream`s saved in a `SessionState`.",null,null],[3,"Client","","A phantom type for the `DefaultSessionState` struct that indicates that the struct should be\ngeared for a client session.",null,null],[3,"Server","","A phantom type for the `DefaultSessionState` struct that indicates that the struct should be\ngeared for a server session.",null,null],[3,"DefaultSessionState","","An implementation of the `SessionState` trait that tracks the active streams in a `HashMap`,\nmapping the stream ID to the concrete `Stream` instance.",null,null],[3,"DefaultStream","","An implementation of the `Stream` trait that saves all headers and data\nin memory.",null,null],[12,"stream_id","","The ID of the stream, if already assigned by the connection.",35,null],[12,"headers","","The headers associated with the stream (i.e. the response headers)",35,null],[12,"body","","The body of the stream (i.e. the response body)",35,null],[12,"state","","The current stream state.",35,null],[4,"StreamState","","The enum represents all the states that an HTTP/2 stream can be found in.",null,null],[13,"Idle","","",36,null],[13,"ReservedLocal","","",36,null],[13,"ReservedRemote","","",36,null],[13,"Open","","",36,null],[13,"HalfClosedRemote","","",36,null],[13,"HalfClosedLocal","","",36,null],[13,"Closed","","",36,null],[4,"StreamDataError","","The enum represents errors that can be returned from the `Stream::get_data_chunk` method.",null,null],[13,"Closed","","Indicates that the stream cannot provide any data, since it is closed for further writes\nfrom the peer's side.",37,null],[13,"Other","","A different error while trying to obtain the data chunk. Wraps a boxed `Error` impl.",37,null],[4,"StreamDataChunk","","The enum represents the successful completion of the `Stream::get_data_chunk` method.",null,null],[13,"Chunk","","A data chunk of the given size, after which more chunks can follow.",38,null],[13,"Last","","The chunk was the last one that the stream will ever write.",38,null],[13,"Unavailable","","No data currently available, but the stream isn't closed yet",38,null],[5,"default_client_state","","Create a new `DefaultSessionState` for a client session.\nThis function is a workaround required due to\n[rust-lang/rust#29023](https://github.com/rust-lang/rust/issues/29023).",null,{"inputs":[],"output":{"name":"defaultsessionstate"}}],[5,"default_server_state","","Create a new `DefaultSessionState` for a server session.\nThis function is a workaround required due to\n[rust-lang/rust#29023](https://github.com/rust-lang/rust/issues/29023).",null,{"inputs":[],"output":{"name":"defaultsessionstate"}}],[8,"Session","","A trait that defines the interface between an `HttpConnection` and the higher-levels that use\nit. Essentially, it allows the `HttpConnection` to pass information onto those higher levels\nthrough a well-defined interface.",null,null],[10,"new_data_chunk","","Notifies the `Session` that a new data chunk has arrived on the\nconnection for a particular stream. Only the raw data is passed\nto the callback (all padding is already discarded by the connection).",39,null],[10,"new_headers","","Notifies the `Session` that headers have arrived for a particular\nstream. The given list of headers is already decoded by the connection.\nTODO: The Session should be notified separately for every header that is decoded.",39,{"inputs":[{"name":"session"},{"name":"streamid"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[10,"end_of_stream","","Notifies the `Session` that a particular stream got closed by the peer.",39,{"inputs":[{"name":"session"},{"name":"streamid"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[10,"rst_stream","","Notifies the `Session` that a particular stream was reset by the peer and provides the\nreason behind it.",39,{"inputs":[{"name":"session"},{"name":"streamid"},{"name":"errorcode"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[10,"new_settings","","Notifies the `Session` that the peer has sent a new set of settings. The session itself is\nresponsible for acknowledging the receipt of the settings.",39,{"inputs":[{"name":"session"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"on_goaway","","Notifies the `Session` that the peer has sent a GOAWAY frame, indicating that the\nconnection is terminated.",39,{"inputs":[{"name":"session"},{"name":"streamid"},{"name":"errorcode"},{"name":"option"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[8,"SessionState","","A trait defining a set of methods for accessing and influencing an HTTP/2 session's state.",null,null],[16,"Stream","","The type of the `Stream` that the `SessionState` manages.",40,null],[10,"insert_outgoing","","Inserts the given `Stream` into the session's state, starting to track it.\nThe `SessionState` should assign it the next available outgoing stream ID.",40,{"inputs":[{"name":"sessionstate"},{"name":"stream"}],"output":{"name":"streamid"}}],[10,"insert_incoming","","Inserts the given `Stream` into the session's state, considering it an incoming\nstream.\nTODO(mlalic): Allow the exact error to propagate out.",40,{"inputs":[{"name":"sessionstate"},{"name":"streamid"},{"name":"stream"}],"output":{"name":"result"}}],[10,"get_stream_ref","","Returns a reference to a `Stream` with the given `StreamId`, if it is found in the current\nsession.",40,{"inputs":[{"name":"sessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[10,"get_stream_mut","","Returns a mutable reference to a `Stream` with the given `StreamId`, if it is found in the\ncurrent session.",40,{"inputs":[{"name":"sessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[10,"remove_stream","","Removes the stream with the given `StreamId` from the session. If the stream was found in\nthe session, it is returned in the result.",40,{"inputs":[{"name":"sessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[10,"iter","","Returns an iterator over the streams currently found in the session.",40,{"inputs":[{"name":"sessionstate"}],"output":{"name":"streamiter"}}],[11,"get_closed","","Returns all streams that are closed and tracked by the session state.",40,{"inputs":[{"name":"sessionstate"}],"output":{"name":"vec"}}],[8,"Stream","","A trait representing a single HTTP/2 stream. An HTTP/2 connection multiplexes a number of\nstreams.",null,null],[10,"new_data_chunk","","Handle a new data chunk that has arrived for the stream.",41,null],[10,"set_headers","","Set headers for a stream. A stream is only allowed to have one set of\nheaders.",41,{"inputs":[{"name":"stream"},{"name":"vec"}],"output":null}],[10,"set_state","","Sets the stream state to the newly provided state.",41,{"inputs":[{"name":"stream"},{"name":"streamstate"}],"output":null}],[11,"on_rst_stream","","Invoked when the session detects that the peer has reset the stream (i.e. sent a RST_STREAM\nframe for this stream).",41,{"inputs":[{"name":"stream"},{"name":"errorcode"}],"output":null}],[10,"get_data_chunk","","Places the next data chunk that should be written onto the stream into the given buffer.",41,null],[10,"state","","Returns the current state of the stream.",41,{"inputs":[{"name":"stream"}],"output":{"name":"streamstate"}}],[11,"close","","Transitions the stream state to closed. After this, the stream is considered to be closed\nfor any further reads or writes.",41,{"inputs":[{"name":"stream"}],"output":null}],[11,"close_local","","Updates the `Stream` status to indicate that it is closed locally.",41,{"inputs":[{"name":"stream"}],"output":null}],[11,"close_remote","","Updates the `Stream` status to indicate that it is closed on the remote peer's side.",41,{"inputs":[{"name":"stream"}],"output":null}],[11,"is_closed","","Returns whether the stream is closed.",41,{"inputs":[{"name":"stream"}],"output":{"name":"bool"}}],[11,"is_closed_local","","Returns whether the stream is closed locally.",41,{"inputs":[{"name":"stream"}],"output":{"name":"bool"}}],[11,"is_closed_remote","","Returns whether the remote peer has closed the stream. This includes a fully closed stream.",41,{"inputs":[{"name":"stream"}],"output":{"name":"bool"}}],[11,"next","","",42,{"inputs":[{"name":"streamiter"}],"output":{"name":"option"}}],[11,"new","","Creates a new `DefaultSessionState` for a client session with no known streams.",43,{"inputs":[{"name":"defaultsessionstate"}],"output":{"name":"defaultsessionstate"}}],[11,"new","","Creates a new `DefaultSessionState` for a server session with no known streams.",43,{"inputs":[{"name":"defaultsessionstate"}],"output":{"name":"defaultsessionstate"}}],[11,"insert_outgoing","","",43,{"inputs":[{"name":"defaultsessionstate"},{"name":"stream"}],"output":{"name":"streamid"}}],[11,"insert_incoming","","",43,{"inputs":[{"name":"defaultsessionstate"},{"name":"streamid"},{"name":"stream"}],"output":{"name":"result"}}],[11,"get_stream_ref","","",43,{"inputs":[{"name":"defaultsessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[11,"get_stream_mut","","",43,{"inputs":[{"name":"defaultsessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[11,"remove_stream","","",43,{"inputs":[{"name":"defaultsessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[11,"iter","","",43,{"inputs":[{"name":"defaultsessionstate"}],"output":{"name":"streamiter"}}],[11,"fmt","","",36,{"inputs":[{"name":"streamstate"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",36,{"inputs":[{"name":"streamstate"},{"name":"streamstate"}],"output":{"name":"bool"}}],[11,"ne","","",36,{"inputs":[{"name":"streamstate"},{"name":"streamstate"}],"output":{"name":"bool"}}],[11,"clone","","",36,{"inputs":[{"name":"streamstate"}],"output":{"name":"streamstate"}}],[11,"fmt","","",37,{"inputs":[{"name":"streamdataerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",37,{"inputs":[{"name":"streamdataerror"},{"name":"e"}],"output":{"name":"streamdataerror"}}],[11,"fmt","","",38,{"inputs":[{"name":"streamdatachunk"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",38,{"inputs":[{"name":"streamdatachunk"},{"name":"streamdatachunk"}],"output":{"name":"bool"}}],[11,"ne","","",38,{"inputs":[{"name":"streamdatachunk"},{"name":"streamdatachunk"}],"output":{"name":"bool"}}],[11,"clone","","",38,{"inputs":[{"name":"streamdatachunk"}],"output":{"name":"streamdatachunk"}}],[11,"clone","","",35,{"inputs":[{"name":"defaultstream"}],"output":{"name":"defaultstream"}}],[11,"new","","Create a new `DefaultStream`, where the ID is not yet assigned.",35,{"inputs":[{"name":"defaultstream"}],"output":{"name":"defaultstream"}}],[11,"with_id","","Create a new `DefaultStream` with the given ID.",35,{"inputs":[{"name":"defaultstream"},{"name":"streamid"}],"output":{"name":"defaultstream"}}],[11,"set_full_data","","Sets the outgoing data of the stream to the given `Vec`.",35,{"inputs":[{"name":"defaultstream"},{"name":"vec"}],"output":null}],[11,"new_data_chunk","","",35,null],[11,"set_headers","","",35,{"inputs":[{"name":"defaultstream"},{"name":"vec"}],"output":null}],[11,"set_state","","",35,{"inputs":[{"name":"defaultstream"},{"name":"streamstate"}],"output":null}],[11,"state","","",35,{"inputs":[{"name":"defaultstream"}],"output":{"name":"streamstate"}}],[11,"get_data_chunk","","",35,null],[0,"priority","solicit::http","The module exposes an API for defining data prioritization strategies.",null,null],[3,"SimplePrioritizer","solicit::http::priority","An implementation of the `DataPrioritizer` trait that is based on finding the first stream from\nthe given `SessionState` instance that can send data and returning this chunk.",null,null],[8,"DataPrioritizer","","A trait that types that want to provide data to an HTTP/2 connection need to implement.",null,null],[10,"get_next_chunk","","Returns the next `DataChunk` that should be sent on the HTTP/2 connection. `None` indicates\nthat currently there was no data that could be sent at that point.",44,{"inputs":[{"name":"dataprioritizer"}],"output":{"name":"httpresult"}}],[11,"new","","Creates a new `SimplePrioritizer` that will use the given state to find stream data that\nshould be sent and use the given buffer to hold the data of the returned chunk.",45,null],[11,"get_next_chunk","","",45,{"inputs":[{"name":"simpleprioritizer"}],"output":{"name":"httpresult"}}],[0,"client","solicit::http","The module contains a number of reusable components for implementing the client side of an\nHTTP/2 connection.",null,null],[3,"ClientStream","solicit::http::client","A convenience wrapper type that represents an established client network transport stream.\nIt wraps the stream itself, the scheme of the protocol to be used, and the remote\nhost name.",null,null],[3,"CleartextConnector","","A struct that establishes a cleartext TCP connection that can be used by an HTTP/2\nconnection. Defaults to using port 80.",null,null],[12,"host","","The host to which the connection should be established",46,null],[12,"port","","The port on which the connection should be established",46,null],[3,"CleartextConnectError","","A newtype wrapping the `io::Error`, as it occurs when attempting to\nestablish an HTTP/2 connection over cleartext TCP (with prior knowledge).",null,null],[3,"RequestStream","","A struct representing a request stream. It provides the headers that are to be sent when\ninitiating the request, as well as a `Stream` instance that handles the received response and\nprovides the request body.",null,null],[12,"headers","","The list of headers that will be sent with the request.",47,null],[12,"stream","","The underlying `Stream` instance, which will handle the response, as well as optionally\nprovide the body of the request.",47,null],[3,"ClientConnection","","The struct extends the `HttpConnection` API with client-specific methods (such as\n`start_request`) and wires the `HttpConnection` to the client `Session` callbacks.",null,null],[12,"state","","The state of the session associated to this client connection. Maintains the status of the\nconnection streams.",48,null],[3,"ClientSession","","An implementation of the `Session` trait specific to handling client HTTP/2 connections.",null,null],[5,"write_preface","","Writes the client preface to the underlying HTTP/2 connection.",null,{"inputs":[{"name":"w"}],"output":{"name":"result"}}],[0,"tls","","The module contains helpers for implementing TLS-based client connections.",null,null],[3,"TlsConnector","solicit::http::client::tls","A struct implementing the functionality of establishing a TLS-backed TCP stream\nthat can be used by an HTTP/2 connection. Takes care to set all the TLS options\nto those allowed by the HTTP/2 spec, as well as of the protocol negotiation.",null,null],[12,"host","","",49,null],[4,"TlsConnectError","","An enum representing possible errors that can arise when trying to\nestablish an HTTP/2 connection over TLS.",null,null],[13,"IoError","","The variant corresponds to the underlying raw TCP connection returning\nan error.",50,null],[13,"SslError","","The variant corresponds to the TLS negotiation returning an error.",50,null],[13,"Http2NotSupported","","The variant corresponds to the case when the TLS connection is\nestablished, but the application protocol that was negotiated didn't\nend up being HTTP/2.\nIt wraps the established SSL stream in order to allow the client to\ndecide what to do with it (and the application protocol that was\nchosen).",50,null],[11,"fmt","","",50,{"inputs":[{"name":"tlsconnecterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",50,{"inputs":[{"name":"tlsconnecterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",50,{"inputs":[{"name":"tlsconnecterror"}],"output":{"name":"str"}}],[11,"cause","","",50,{"inputs":[{"name":"tlsconnecterror"}],"output":{"name":"option"}}],[11,"from","","",50,{"inputs":[{"name":"tlsconnecterror"},{"name":"error"}],"output":{"name":"tlsconnecterror"}}],[11,"from","","",50,{"inputs":[{"name":"tlsconnecterror"},{"name":"sslerror"}],"output":{"name":"tlsconnecterror"}}],[11,"new","","Creates a new `TlsConnector` that will create a new `SslContext` before\ntrying to establish the TLS connection. The path to the CA file that the\ncontext will use needs to be provided.",49,{"inputs":[{"name":"tlsconnector"},{"name":"str"},{"name":"p"}],"output":{"name":"tlsconnector"}}],[11,"with_context","","Creates a new `TlsConnector` that will use the provided context to\ncreate the `SslStream` that will back the HTTP/2 connection.",49,{"inputs":[{"name":"tlsconnector"},{"name":"str"},{"name":"sslcontext"}],"output":{"name":"tlsconnector"}}],[11,"build_default_context","","Builds up a default `SslContext` instance wth TLS settings that the\nHTTP/2 spec mandates. The path to the CA file needs to be provided.",49,{"inputs":[{"name":"tlsconnector"},{"name":"path"}],"output":{"name":"result"}}],[11,"connect","","",49,{"inputs":[{"name":"tlsconnector"}],"output":{"name":"result"}}],[8,"HttpConnectError","solicit::http::client","A marker trait for errors raised by attempting to establish an HTTP/2\nconnection.",null,null],[8,"HttpConnect","","A trait that can be implemented by structs that want to provide the\nfunctionality of establishing network connections for use by HTTP/2 connections.",null,null],[16,"Stream","","The type of the underlying transport stream that the `HttpConnection`s\nproduced by this `HttpConnect` implementation will be based on.",51,null],[16,"Err","","The type of the error that can be produced by trying to establish the\nconnection (i.e. calling the `connect` method).",51,null],[10,"connect","","Establishes a network connection that can be used by HTTP/2 connections.",51,{"inputs":[{"name":"httpconnect"}],"output":{"name":"result"}}],[11,"from","solicit::http","",3,{"inputs":[{"name":"httperror"},{"name":"e"}],"output":{"name":"httperror"}}],[11,"new","solicit::http::client","Creates a new `CleartextConnector` that will attempt to establish a connection to the given\nhost on port 80.",46,{"inputs":[{"name":"cleartextconnector"},{"name":"str"}],"output":{"name":"cleartextconnector"}}],[11,"with_port","","Creates a new `CleartextConnector` that will attempt to establish a connection to the given\nhost on the given port.",46,{"inputs":[{"name":"cleartextconnector"},{"name":"str"},{"name":"u16"}],"output":{"name":"cleartextconnector"}}],[11,"fmt","","",52,{"inputs":[{"name":"cleartextconnecterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",52,{"inputs":[{"name":"cleartextconnecterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",52,{"inputs":[{"name":"cleartextconnecterror"}],"output":{"name":"str"}}],[11,"cause","","",52,{"inputs":[{"name":"cleartextconnecterror"}],"output":{"name":"option"}}],[11,"from","","",52,{"inputs":[{"name":"cleartextconnecterror"},{"name":"error"}],"output":{"name":"cleartextconnecterror"}}],[11,"connect","","Establishes a cleartext TCP connection based on the host and port.\nIf it is not possible, returns an `HttpError`.",46,{"inputs":[{"name":"cleartextconnector"}],"output":{"name":"result"}}],[11,"with_connection","","Creates a new `ClientConnection` that will use the given `HttpConnection`\nfor all its underlying HTTP/2 communication.",48,{"inputs":[{"name":"clientconnection"},{"name":"httpconnection"},{"name":"state"}],"output":{"name":"clientconnection"}}],[11,"scheme","","Returns the scheme of the underlying `HttpConnection`.",48,{"inputs":[{"name":"clientconnection"}],"output":{"name":"httpscheme"}}],[11,"expect_settings","","Handles the next frame provided by the given frame receiver and expects it to be a\n`SETTINGS` frame. If it is not, it returns an error.",48,{"inputs":[{"name":"clientconnection"},{"name":"recv"},{"name":"sender"}],"output":{"name":"httpresult"}}],[11,"start_request","","Starts a new request based on the given `RequestStream`.",48,{"inputs":[{"name":"clientconnection"},{"name":"requeststream"},{"name":"s"}],"output":{"name":"httpresult"}}],[11,"handle_next_frame","","Fully handles the next incoming frame provided by the given `ReceiveFrame` instance.\nHandling a frame may cause changes to the session state exposed by the `ClientConnection`.",48,{"inputs":[{"name":"clientconnection"},{"name":"recv"},{"name":"sender"}],"output":{"name":"httpresult"}}],[11,"send_next_data","","Queues a new DATA frame onto the underlying `SendFrame`.",48,{"inputs":[{"name":"clientconnection"},{"name":"s"}],"output":{"name":"httpresult"}}],[11,"new","","Returns a new `ClientSession` associated to the given state.",53,{"inputs":[{"name":"clientsession"},{"name":"state"},{"name":"s"}],"output":{"name":"clientsession"}}],[11,"new_data_chunk","","",53,null],[11,"new_headers","","",53,{"inputs":[{"name":"clientsession"},{"name":"streamid"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"end_of_stream","","",53,{"inputs":[{"name":"clientsession"},{"name":"streamid"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"rst_stream","","",53,{"inputs":[{"name":"clientsession"},{"name":"streamid"},{"name":"errorcode"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"new_settings","","",53,{"inputs":[{"name":"clientsession"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[0,"server","solicit::http","The module contains a number of reusable components for implementing the server side of an\nHTTP/2 connection.",null,null],[3,"ServerSession","solicit::http::server","An implementation of the `Session` trait for a server-side HTTP/2 connection.",null,null],[3,"ServerConnection","","The struct provides a more convenient API for server-related functionality of an HTTP/2\nconnection, such as sending a response back to the client.",null,null],[12,"state","","The state of the session associated to this client connection. Maintains the status of the\nconnection streams.",54,null],[8,"StreamFactory","","The `ServerSession` requires an instance of a type that implements this trait in order to\ncreate a new `Stream` instance once it detects that a client has initiated a new stream. The\nfactory should take care to provide an appropriate `Stream` implementation that will be able to\nhandle reading the request and generating the response, according to the needs of the\nunderlying application.",null,null],[16,"Stream","","",55,null],[10,"create","","Create a new `Stream` with the given ID.",55,{"inputs":[{"name":"streamfactory"},{"name":"streamid"}],"output":{"name":"stream"}}],[11,"new","","",56,{"inputs":[{"name":"serversession"},{"name":"state"},{"name":"f"},{"name":"s"}],"output":{"name":"serversession"}}],[11,"new_data_chunk","","",56,null],[11,"new_headers","","",56,{"inputs":[{"name":"serversession"},{"name":"streamid"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"end_of_stream","","",56,{"inputs":[{"name":"serversession"},{"name":"streamid"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"rst_stream","","",56,{"inputs":[{"name":"serversession"},{"name":"streamid"},{"name":"errorcode"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"new_settings","","",56,{"inputs":[{"name":"serversession"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"with_connection","","Creates a new `ServerConnection` that will use the given `HttpConnection` for its\nunderlying HTTP/2 communication. The `state` and `factory` represent, respectively, the\ninitial state of the connection and an instance of the `StreamFactory` type (allowing the\nclient to handle newly created streams).",54,{"inputs":[{"name":"serverconnection"},{"name":"httpconnection"},{"name":"state"},{"name":"f"}],"output":{"name":"serverconnection"}}],[11,"scheme","","Returns the scheme of the underlying `HttpConnection`.",54,{"inputs":[{"name":"serverconnection"}],"output":{"name":"httpscheme"}}],[11,"send_settings","","Send the current settings associated to the `ServerConnection` to the client.",54,{"inputs":[{"name":"serverconnection"},{"name":"s"}],"output":{"name":"httpresult"}}],[11,"expect_settings","","Handles the next frame on the given `ReceiveFrame` instance and expects it to be a\n(non-ACK) SETTINGS frame. Returns an error if not.",54,{"inputs":[{"name":"serverconnection"},{"name":"recv"},{"name":"sender"}],"output":{"name":"httpresult"}}],[11,"handle_next_frame","","Fully handles the next frame provided by the given `ReceiveFrame` instance.\nHandling the frame can cause the session state of the `ServerConnection` to update.",54,{"inputs":[{"name":"serverconnection"},{"name":"recv"},{"name":"sender"}],"output":{"name":"httpresult"}}],[11,"start_response","","Starts a response on the stream with the given ID by sending the given headers.",54,{"inputs":[{"name":"serverconnection"},{"name":"vec"},{"name":"streamid"},{"name":"endstream"},{"name":"s"}],"output":{"name":"httpresult"}}],[11,"send_next_data","","Queues a new DATA frame onto the underlying `SendFrame`.",54,{"inputs":[{"name":"serverconnection"},{"name":"s"}],"output":{"name":"httpresult"}}],[6,"StreamId","solicit::http","An alias for the type that represents the ID of an HTTP/2 stream",null,null],[6,"OwnedHeader","","An alias for the type that represents an HTTP/2 header where both the name and the value is\nowned.",null,null],[6,"StaticHeader","","A type alias for a `Header` where both the name, as well as the value must have a `'static`\nlifetime if it is borrowed. Owned parts are allowed.",null,null],[6,"HttpResult","","A convenience `Result` type that has the `HttpError` type as the error\ntype and a generic Ok result type.",null,null],[6,"StaticResponse","","A type alias for a `Response` where all headers' names and values must have a `'static`\nlifetime if they are borrowed. This means that the parts can also be owned.",null,null],[17,"INITIAL_CONNECTION_WINDOW_SIZE","","The initial size of the connections' flow control window.",null,null],[17,"ALPN_PROTOCOLS","","A set of protocol names that the library should use to indicate that HTTP/2\nis supported during protocol negotiation (NPN or ALPN).\nWe include some of the drafts' protocol names, since there is basically no\ndifference for all intents and purposes (and some servers out there still\nonly officially advertise draft support).\nTODO: Eventually only use \"h2\".",null,null],[11,"from","","",57,{"inputs":[{"name":"headerpart"},{"name":"vec"}],"output":{"name":"headerpart"}}],[11,"from","","",57,null],[11,"from","","",57,{"inputs":[{"name":"headerpart"},{"name":"cow"}],"output":{"name":"headerpart"}}],[11,"from","","",57,null],[11,"from","","",57,null],[11,"from","","",57,null],[11,"from","","",57,null],[11,"from","","",57,null],[11,"from","","",57,null],[11,"from","","",57,null],[11,"from","","",57,null],[11,"from","","",57,null],[11,"from","","",57,null],[11,"from","","",57,null],[11,"eq","","",58,{"inputs":[{"name":"ownedheader"},{"name":"header"}],"output":{"name":"bool"}}],[11,"eq","","",59,{"inputs":[{"name":"header"},{"name":"ownedheader"}],"output":{"name":"bool"}}],[11,"eq","","",59,{"inputs":[{"name":"header"},{"name":"header"}],"output":{"name":"bool"}}],[11,"ne","","",59,{"inputs":[{"name":"header"},{"name":"header"}],"output":{"name":"bool"}}],[11,"clone","","",59,{"inputs":[{"name":"header"}],"output":{"name":"header"}}],[11,"fmt","","",59,{"inputs":[{"name":"header"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `Header` with the given name and value.",59,{"inputs":[{"name":"header"},{"name":"n"},{"name":"v"}],"output":{"name":"header"}}],[11,"name","","Return a borrowed representation of the `Header` name.",59,null],[11,"value","","Return a borrowed representation of the `Header` value.",59,null],[11,"into","","",59,{"inputs":[{"name":"header"}],"output":{"name":"ownedheader"}}],[11,"into","","",58,{"inputs":[{"name":"ownedheader"}],"output":{"name":"header"}}],[11,"eq","","",2,{"inputs":[{"name":"errorcode"},{"name":"errorcode"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"errorcode"},{"name":"errorcode"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"errorcode"}],"output":{"name":"errorcode"}}],[11,"fmt","","",2,{"inputs":[{"name":"errorcode"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","Converts the given `u32` number to the appropriate `ErrorCode` variant.",2,{"inputs":[{"name":"errorcode"},{"name":"u32"}],"output":{"name":"errorcode"}}],[11,"as_ref","","",2,{"inputs":[{"name":"errorcode"}],"output":{"name":"str"}}],[11,"into","","",2,{"inputs":[{"name":"errorcode"}],"output":{"name":"u32"}}],[11,"clone","","",60,{"inputs":[{"name":"connectionerror"}],"output":{"name":"connectionerror"}}],[11,"eq","","",60,{"inputs":[{"name":"connectionerror"},{"name":"connectionerror"}],"output":{"name":"bool"}}],[11,"ne","","",60,{"inputs":[{"name":"connectionerror"},{"name":"connectionerror"}],"output":{"name":"bool"}}],[11,"fmt","","",60,{"inputs":[{"name":"connectionerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `ConnectionError` with no associated debug data.",60,{"inputs":[{"name":"connectionerror"},{"name":"errorcode"}],"output":{"name":"connectionerror"}}],[11,"with_debug_data","","Creates a new `ConnectionError` with the given associated debug data.",60,{"inputs":[{"name":"connectionerror"},{"name":"errorcode"},{"name":"vec"}],"output":{"name":"connectionerror"}}],[11,"error_code","","The error code of the underlying error.",60,{"inputs":[{"name":"connectionerror"}],"output":{"name":"errorcode"}}],[11,"debug_data","","The debug data attached to the connection error, if any.",60,{"inputs":[{"name":"connectionerror"}],"output":{"name":"option"}}],[11,"debug_str","","The debug data interpreted as a string, if possible.",60,{"inputs":[{"name":"connectionerror"}],"output":{"name":"option"}}],[11,"fmt","","",60,{"inputs":[{"name":"connectionerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",60,{"inputs":[{"name":"connectionerror"}],"output":{"name":"str"}}],[11,"fmt","","",3,{"inputs":[{"name":"httperror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",3,{"inputs":[{"name":"httperror"},{"name":"error"}],"output":{"name":"httperror"}}],[11,"fmt","","",3,{"inputs":[{"name":"httperror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",3,{"inputs":[{"name":"httperror"}],"output":{"name":"str"}}],[11,"cause","","",3,{"inputs":[{"name":"httperror"}],"output":{"name":"option"}}],[11,"eq","","",61,{"inputs":[{"name":"windowsize"},{"name":"windowsize"}],"output":{"name":"bool"}}],[11,"ne","","",61,{"inputs":[{"name":"windowsize"},{"name":"windowsize"}],"output":{"name":"bool"}}],[11,"clone","","",61,{"inputs":[{"name":"windowsize"}],"output":{"name":"windowsize"}}],[11,"fmt","","",61,{"inputs":[{"name":"windowsize"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"try_increase","","Tries to increase the window size by the given delta. If the WindowSize would overflow the\nmaximum allowed value (2^31 - 1), returns an error case. If the increase succeeds, returns\n`Ok`.",61,{"inputs":[{"name":"windowsize"},{"name":"u32"}],"output":{"name":"result"}}],[11,"try_decrease","","Tries to decrease the size of the window by the given delta.",61,{"inputs":[{"name":"windowsize"},{"name":"i32"}],"output":{"name":"result"}}],[11,"new","","Creates a new `WindowSize` with the given initial size.",61,{"inputs":[{"name":"windowsize"},{"name":"i32"}],"output":{"name":"windowsize"}}],[11,"size","","Returns the current size of the window.",61,{"inputs":[{"name":"windowsize"}],"output":{"name":"i32"}}],[11,"eq","","",4,{"inputs":[{"name":"httpscheme"},{"name":"httpscheme"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"httpscheme"},{"name":"httpscheme"}],"output":{"name":"bool"}}],[11,"clone","","",4,{"inputs":[{"name":"httpscheme"}],"output":{"name":"httpscheme"}}],[11,"fmt","","",4,{"inputs":[{"name":"httpscheme"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"as_bytes","","Returns a byte string representing the scheme.",4,null],[11,"clone","","",0,{"inputs":[{"name":"response"}],"output":{"name":"response"}}],[11,"new","","Creates a new `Response` with all the components already provided.",0,{"inputs":[{"name":"response"},{"name":"streamid"},{"name":"vec"},{"name":"vec"}],"output":{"name":"response"}}],[11,"status_code","","Gets the response status code from the pseudo-header. If the response\ndoes not contain the response as the first pseuo-header, an error is\nreturned as such a response is malformed.",0,{"inputs":[{"name":"response"}],"output":{"name":"httpresult"}}],[11,"clone","","",1,{"inputs":[{"name":"request"}],"output":{"name":"request"}}],[0,"client","solicit","The module contains implementations of HTTP/2 clients that could be\ndirectly used to access HTTP/2 servers, i.e. send requests and read\nresponses.",null,null],[3,"SimpleClient","solicit::client","A struct implementing a simple HTTP/2 client.",null,null],[3,"Client","","A struct representing an HTTP/2 client that receives responses to its\nrequests asynchronously. Additionally, this client can be cloned and all\nclones can issue (concurrently) requests to the server, using the same\nunderlying HTTP/2 connection.",null,null],[11,"with_stream","","Creates a new `SimpleClient` instance that will use the given `stream` instance for its\nunderlying communication with the host. Additionally, requires the host identifier and the\nscheme of the connection.",62,{"inputs":[{"name":"simpleclient"},{"name":"s"},{"name":"string"},{"name":"httpscheme"}],"output":{"name":"httpresult"}}],[11,"with_connector","","A convenience constructor that first tries to establish an HTTP/2\nconnection by using the given connector instance (an implementation of\nthe `HttpConnect` trait).",62,{"inputs":[{"name":"simpleclient"},{"name":"c"}],"output":{"name":"httpresult"}}],[11,"request","","Send a request to the server. Blocks until the entire request has been\nsent.",62,null],[11,"get_response","","Gets the response for the stream with the given ID. If a valid stream ID\nis given, it blocks until a response is received.",62,{"inputs":[{"name":"simpleclient"},{"name":"streamid"}],"output":{"name":"httpresult"}}],[11,"get","","Performs a GET request on the given path. This is a shortcut method for\ncalling `request` followed by `get_response` for the returned stream ID.",62,null],[11,"post","","Performs a POST request on the given path.",62,null],[11,"clone","","",63,{"inputs":[{"name":"client"}],"output":{"name":"client"}}],[11,"drop","","",63,{"inputs":[{"name":"client"}],"output":null}],[11,"with_connector","","Creates a brand new HTTP/2 client. This means that a new HTTP/2\nconnection will be established behind the scenes. A thread is spawned\nto handle the connection in the background, so that the thread that\ncreates the client can use it asynchronously.",63,{"inputs":[{"name":"client"},{"name":"c"}],"output":{"name":"option"}}],[11,"request","","Issues a new request to the server.",63,null],[11,"get","","Issues a GET request to the server.",63,null],[11,"post","","Issues a POST request to the server.",63,null],[0,"server","solicit","The module contains a simple HTTP/2 server implementation.",null,null],[3,"ServerRequest","solicit::server","The struct represents a fully received request.",null,null],[12,"stream_id","","",64,null],[12,"headers","","",64,null],[12,"body","","",64,null],[3,"SimpleServer","","The struct implements a simple HTTP/2 server that allows users to register a request handler (a\ncallback taking a `ServerRequest` and returning a `Response`) which is run on all received\nrequests.",null,null],[11,"new","","Creates a new `SimpleServer` that will use the given `TransportStream` to communicate to\nthe client. Assumes that the stream is fully uninitialized -- no preface sent or read yet.",65,{"inputs":[{"name":"simpleserver"},{"name":"ts"},{"name":"h"}],"output":{"name":"httpresult"}}],[11,"handle_next","","Handles the next incoming frame, blocking to receive it if nothing is available on the\nunderlying stream.",65,{"inputs":[{"name":"simpleserver"}],"output":{"name":"httpresult"}}]],"paths":[[3,"Response"],[3,"Request"],[4,"ErrorCode"],[4,"HttpError"],[4,"HttpScheme"],[8,"FrameBuilder"],[3,"DataFrame"],[4,"DataFlag"],[3,"DataChunk"],[3,"StreamDependency"],[3,"HeadersFrame"],[4,"HeadersFlag"],[3,"RstStreamFrame"],[3,"SettingsFrame"],[4,"HttpSetting"],[4,"SettingsFlag"],[3,"GoawayFrame"],[3,"WindowUpdateFrame"],[8,"FrameIR"],[8,"Flag"],[8,"Frame"],[3,"NoFlag"],[3,"RawFrame"],[8,"TransportStream"],[3,"TcpStream"],[3,"TransportReceiveFrame"],[3,"SslStream"],[3,"HttpConnection"],[3,"DataChunk"],[4,"HttpFrame"],[4,"SendStatus"],[4,"EndStream"],[8,"SendFrame"],[8,"ReceiveFrame"],[3,"HttpConnectionSender"],[3,"DefaultStream"],[4,"StreamState"],[4,"StreamDataError"],[4,"StreamDataChunk"],[8,"Session"],[8,"SessionState"],[8,"Stream"],[3,"StreamIter"],[3,"DefaultSessionState"],[8,"DataPrioritizer"],[3,"SimplePrioritizer"],[3,"CleartextConnector"],[3,"RequestStream"],[3,"ClientConnection"],[3,"TlsConnector"],[4,"TlsConnectError"],[8,"HttpConnect"],[3,"CleartextConnectError"],[3,"ClientSession"],[3,"ServerConnection"],[8,"StreamFactory"],[3,"ServerSession"],[3,"HeaderPart"],[6,"OwnedHeader"],[3,"Header"],[3,"ConnectionError"],[3,"WindowSize"],[3,"SimpleClient"],[3,"Client"],[3,"ServerRequest"],[3,"SimpleServer"]]};
initSearch(searchIndex);
